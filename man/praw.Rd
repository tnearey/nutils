% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/praw.R
\name{praw}
\alias{praw}
\title{Pattern (or Pseudo) raw: Approximate Python-like `raw` Strings}
\usage{
praw(pat, cesc = "`")
}
\arguments{
\item{pat}{a string or character vector}

\item{cesc}{a character or string (default `)  to be substituted by
double \\ in the returned pattern string where any cescs appeared on input.}
}
\value{
the pattern with the `cesc` character replaced by two backslashes. See details.
}
\description{
Uses `backtick` (or another character or string) as an alias for `backslash` in regex pattern strings,
}
\details{
Literal occurrences of characters such as ([.|)\\^{}+$*?:] often need to be escaped
    in regular expression patterns. This may make them look very different from, e.g.,
    Python raw string patterns.
    Thus, the equivalent of Python's  \code{pyPat= r'\\(\\s*\\w+\\s*\\)'} would have to look like:
     \code{rPat <- "\\\\(\\\\s*\\\\w+\\\\s*\\\\)"}. With \code{praw()} we can instead use
      \code{erPat <- ('`(`s*`w+`s*`)')}
     To match a literal single backslash in a string,  \code{pat <- praw('``')} is necessary, generating  the same
     string as \code{pat= '\\\\'}.
     To match a double literal backslash R would require  an eight 'leaning toothpicks' pattern \code{('\\\\\\\\\\\\\\\\')}, but with praw, we get away with
     four backticks \code{ pat <- praw('````')}, yielding \\\\\\\\\\\\\\\\.
     If a literal backtick is in the pattern of interest, you can substitute another unused character to stand in for \\\\ sequences.
}
\examples{
praw('`(`s*`w+`s*`)') == "\\\\(\\\\s*\\\\w+\\\\s*\\\\)"

# Replace a\\\\b with a:b

#' gsub(praw("````"), ":", "a\\\\\\\\b")
# or  using '\%' instead of `'`:
gsub(praw('\%\%\%\%','\%'), ":", "a\\\\\\\\b")
}
